{
    "docs": [
        {
            "location": "/",
            "text": "MongoDB PHP Library\n\u00b6\n\n\nThis library provides a high-level abstraction around the lower-level\n\nPHP driver\n (i.e. the \nmongodb\n extension).\n\n\nWhile the extension provides a limited API for executing commands, queries, and\nwrite operations, this library implements an API similar to that of the\n\nlegacy PHP driver\n. It contains\nabstractions for client, database, and collection objects, and provides methods\nfor CRUD operations and common commands (e.g. index and collection management).\nSupport for GridFS is forthcoming.\n\n\nIf you are developing an application with MongoDB, you should consider using\nthis library, or another high-level abstraction, instead of the extension alone.\n\n\nFor additional information about this library and the \nmongodb\n extension,\nsee the \nArchitecture Overview\n\narticle in the driver documentation. \nDerick Rethans\n\nhas also written a series of blog posts entitled \nNew MongoDB Drivers for PHP\nand HHVM\n:\n\n\n\n\nPart One: History\n\n\nPart Two: Architecture\n\n\nPart Three: Cursor Behaviour\n\n\n\n\nAPI Documentation\n\u00b6\n\n\nGenerated API documentation for the library is available at:\n\n\n\n\nhttp://mongodb.github.io/mongo-php-library/api\n\n\n\n\nMongoDB Tutorial\n\u00b6\n\n\nIf you are a new MongoDB user, these links should help you become more familiar\nwith MongoDB and introduce some of the concepts and terms you will encounter in\nthis documentation:\n\n\n\n\nIntroduction to CRUD operations in MongoDB\n\n\nWhat is a MongoDB document?\n\n\nMongoDB\u2019s \ndot notation\n for accessing document properties\n\n\nObjectId: MongoDB\u2019s document identifier",
            "title": "Home"
        },
        {
            "location": "/#mongodb-php-library",
            "text": "This library provides a high-level abstraction around the lower-level PHP driver  (i.e. the  mongodb  extension).  While the extension provides a limited API for executing commands, queries, and\nwrite operations, this library implements an API similar to that of the legacy PHP driver . It contains\nabstractions for client, database, and collection objects, and provides methods\nfor CRUD operations and common commands (e.g. index and collection management).\nSupport for GridFS is forthcoming.  If you are developing an application with MongoDB, you should consider using\nthis library, or another high-level abstraction, instead of the extension alone.  For additional information about this library and the  mongodb  extension,\nsee the  Architecture Overview \narticle in the driver documentation.  Derick Rethans \nhas also written a series of blog posts entitled  New MongoDB Drivers for PHP\nand HHVM :   Part One: History  Part Two: Architecture  Part Three: Cursor Behaviour",
            "title": "MongoDB PHP Library"
        },
        {
            "location": "/#api-documentation",
            "text": "Generated API documentation for the library is available at:   http://mongodb.github.io/mongo-php-library/api",
            "title": "API Documentation"
        },
        {
            "location": "/#mongodb-tutorial",
            "text": "If you are a new MongoDB user, these links should help you become more familiar\nwith MongoDB and introduce some of the concepts and terms you will encounter in\nthis documentation:   Introduction to CRUD operations in MongoDB  What is a MongoDB document?  MongoDB\u2019s  dot notation  for accessing document properties  ObjectId: MongoDB\u2019s document identifier",
            "title": "MongoDB Tutorial"
        },
        {
            "location": "/getting-started/",
            "text": "Getting Started\n\u00b6\n\n\nRequirements\n\u00b6\n\n\nSince this library is only a high-level abstraction for the driver, it requires\nthat the \nmongodb\n extension be installed:\n\n\n$ pecl install mongodb\n$ echo \"extension=mongodb.so\" >> `php --ini | grep \"Loaded Configuration\" | sed -e \"s|.*:\\s*||\"`\n\n\n\n\nInstructions for installing the \nmongodb\n extension on HHVM may be found in the\n\nInstallation with HHVM\n\narticle in the driver documentation.\n\n\nInstallation\n\u00b6\n\n\nThe preferred method of installing this library is with\n\nComposer\n by running the following from your project\nroot:\n\n\n$ composer require \"mongodb/mongodb=^1.0.0\"\n\n\n\n\nWhile not recommended, the package may also be installed manually via source\ntarballs attached to\n\nGitHub releases\n.\n\n\nConfigure Autoloading\n\u00b6\n\n\nOnce the library is installed, ensure that your application includes Composer\u2019s\nautoloader.\n\n\n// This path should point to Composer's autoloader\nrequire_once __DIR__ . \"/vendor/autoload.php\";\n\n\n\n\nMore information on this setup may be found in Composer\u2019s\n\nautoloading documentation\n.\n\n\nIf you have installed the package manually (e.g. from a source tarball), you\nwill likely need configure autoloading manually:\n\n\n\n\nMap the top-level \nMongoDB\\\n namespace to the \nsrc/\n directory using your\n   preferred autoloader implementation\n\n\nManually require the \nsrc/functions.php\n file, since PHP does not yet support\n   function autoloading",
            "title": "Getting Started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "Requirements \u00b6  Since this library is only a high-level abstraction for the driver, it requires\nthat the  mongodb  extension be installed:  $ pecl install mongodb\n$ echo \"extension=mongodb.so\" >> `php --ini | grep \"Loaded Configuration\" | sed -e \"s|.*:\\s*||\"`  Instructions for installing the  mongodb  extension on HHVM may be found in the Installation with HHVM \narticle in the driver documentation.  Installation \u00b6  The preferred method of installing this library is with Composer  by running the following from your project\nroot:  $ composer require \"mongodb/mongodb=^1.0.0\"  While not recommended, the package may also be installed manually via source\ntarballs attached to GitHub releases .  Configure Autoloading \u00b6  Once the library is installed, ensure that your application includes Composer\u2019s\nautoloader.  // This path should point to Composer's autoloader\nrequire_once __DIR__ . \"/vendor/autoload.php\";  More information on this setup may be found in Composer\u2019s autoloading documentation .  If you have installed the package manually (e.g. from a source tarball), you\nwill likely need configure autoloading manually:   Map the top-level  MongoDB\\  namespace to the  src/  directory using your\n   preferred autoloader implementation  Manually require the  src/functions.php  file, since PHP does not yet support\n   function autoloading",
            "title": "Getting Started"
        },
        {
            "location": "/example-data/",
            "text": "Example Data\n\u00b6\n\n\nSome examples in this documentation use example data fixtures from\n\nzips.json\n. This is a dataset comprised of\nUnited States postal codes, populations, and geographic locations.\n\n\nImporting the dataset into MongoDB can be done in several ways. The following\nexample uses \nPHP driver\n (i.e. \nmongodb\n extension).\n\n\n$file = 'http://media.mongodb.org/zips.json';\n$zips = file($file, FILE_IGNORE_NEW_LINES);\n\n$bulk = new MongoDB\\Driver\\BulkWrite;\n\nforeach ($zips as $string) {\n    $document = json_decode($string);\n    $bulk->insert($document);\n}\n\n$manager = new MongoDB\\Driver\\Manager('mongodb://localhost');\n\n$result = $manager->executeBulkWrite('demo.zips', $bulk);\nprintf(\"Inserted %d documents\\n\", $result->getInsertedCount());\n\n\n\n\nExecuting this script should yield the following output:\n\n\nInserted 29353 documents\n\n\n\n\nYou may also import the dataset using the\n\nmongoimport\n\ncommand, which is included with MongoDB:\n\n\n$ mongoimport --db demo --collection zips --file zips.json --drop",
            "title": "Example Data"
        },
        {
            "location": "/example-data/#example-data",
            "text": "Some examples in this documentation use example data fixtures from zips.json . This is a dataset comprised of\nUnited States postal codes, populations, and geographic locations.  Importing the dataset into MongoDB can be done in several ways. The following\nexample uses  PHP driver  (i.e.  mongodb  extension).  $file = 'http://media.mongodb.org/zips.json';\n$zips = file($file, FILE_IGNORE_NEW_LINES);\n\n$bulk = new MongoDB\\Driver\\BulkWrite;\n\nforeach ($zips as $string) {\n    $document = json_decode($string);\n    $bulk->insert($document);\n}\n\n$manager = new MongoDB\\Driver\\Manager('mongodb://localhost');\n\n$result = $manager->executeBulkWrite('demo.zips', $bulk);\nprintf(\"Inserted %d documents\\n\", $result->getInsertedCount());  Executing this script should yield the following output:  Inserted 29353 documents  You may also import the dataset using the mongoimport \ncommand, which is included with MongoDB:  $ mongoimport --db demo --collection zips --file zips.json --drop",
            "title": "Example Data"
        },
        {
            "location": "/classes/client/",
            "text": "MongoDB\\Client\n\u00b6\n\n\nMongoDB\\Client\n serves as an entry point for the library and driver. It is\nconstructed with the same arguments as the driver\u2019s \nMongoDB\\Driver\\Manager\n\nclass, which it composes. Additional reference may be found in the\n\nMongoDB\\Driver\\Manager::__construct\n\nand\n\nConnection String\n\ndocumentation.\n\n\n/* By default, the driver connects to mongodb://localhost:27017 */\n$client = new MongoDB\\Client;\n\n/* Any URI options will be merged into the URI string */\n$client = new MongoDB\\Client(\n    'mongodb://rs1.example.com,rs2.example.com/?replicaSet=myReplicaSet',\n    ['readPreference' => 'secondaryPreferred']\n);\n\n\n\n\nDriver options may be provided as the third argument. In addition to options\nsupported by the extension, the PHP library allows you to specify a default\ntype map to apply to the cursors it creates. A more thorough description of type\nmaps may be found in the driver\u2019s\n\nPersistence documentation\n.\n\n\n/* This example instructs the library to unserialize root and embedded BSON\n * documents as PHP arrays, like the legacy driver (i.e. ext-mongo). */\n$client = new MongoDB\\Client(null, [], [\n    'typeMap' => ['root' => 'array', 'document' => 'array'],\n);\n\n\n\n\nBy default, the library will unserialize BSON documents and arrays as\n\nMongoDB\\Model\\BSONDocument\n and \nMongoDB\\Model\\BSONArray\n objects,\nrespectively. Each of these model classes extends PHP\u2019s\n\nArrayObject\n class and implements the driver\u2019s\n\nMongoDB\\BSON\\Serializable\n and\n\nMongoDB\\BSON\\Unserializable\n\ninterfaces.\n\n\nSelecting Databases and Collections\n\u00b6\n\n\nThe Client class provides methods for creating Database or Collection instances\n(using its internal Manager instance). When selecting a Database or Collection,\nthe child will inherit options (e.g. read preference, type map) from the Client.\nNew options may also be provided to the \nselectDatabase()\n and\n\nselectCollection()\n methods.\n\n\n$client = new MongoDB\\Client;\n\n/* Select the \"demo\" database */\n$db = $client->selectDatabase('demo');\n\n/* Select the \"demo.users\" collection */\n$collection = $client->selectCollection('demo', 'users');\n\n/* selectDatabase() and selectCollection() also take an options array, which can\n * override any options inherited from the Client. */\n$db = $client->selectDatabase('demo', [\n    'readPreference' => new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_SECONDARY),\n]);\n\n/* The property accessor may also be used to select a database without\n * specifying additional options. PHP's complex syntax may be used for selecting\n * databases whose names contain special characters (e.g. \"-\"). */\n$db = $client->demo;\n$db = $client->{'another-app'};\n\n\n\n\nDatabase Management\n\u00b6\n\n\nThe Client class has several methods for managing databases.\n\n\nDropping Databases\n\u00b6\n\n\n$client = new MongoDB\\Client;\n\n$result = $client->dropDatabase('demo');\nvar_dump($result);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#8 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(2) {\n    [\"dropped\"]=>\n    string(4) \"demo\"\n    [\"ok\"]=>\n    float(1)\n  }\n}\n\n\n\n\nEnumerating Databases\n\u00b6\n\n\n$client = new MongoDB\\Client;\n\n/* listDatabases() returns an iterator of MongoDB\\Model\\DatabaseInfo objects */\nforeach ($client->listDatabases() as $databaseInfo) {\n    var_dump($databaseInfo);\n}\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\DatabaseInfo)#4 (3) {\n  [\"name\"]=>\n  string(5) \"local\"\n  [\"sizeOnDisk\"]=>\n  float(65536)\n  [\"empty\"]=>\n  bool(false)\n}\nobject(MongoDB\\Model\\DatabaseInfo)#7 (3) {\n  [\"name\"]=>\n  string(4) \"test\"\n  [\"sizeOnDisk\"]=>\n  float(32768)\n  [\"empty\"]=>\n  bool(false)\n}",
            "title": "Client"
        },
        {
            "location": "/classes/client/#mongodbclient",
            "text": "MongoDB\\Client  serves as an entry point for the library and driver. It is\nconstructed with the same arguments as the driver\u2019s  MongoDB\\Driver\\Manager \nclass, which it composes. Additional reference may be found in the MongoDB\\Driver\\Manager::__construct \nand Connection String \ndocumentation.  /* By default, the driver connects to mongodb://localhost:27017 */\n$client = new MongoDB\\Client;\n\n/* Any URI options will be merged into the URI string */\n$client = new MongoDB\\Client(\n    'mongodb://rs1.example.com,rs2.example.com/?replicaSet=myReplicaSet',\n    ['readPreference' => 'secondaryPreferred']\n);  Driver options may be provided as the third argument. In addition to options\nsupported by the extension, the PHP library allows you to specify a default\ntype map to apply to the cursors it creates. A more thorough description of type\nmaps may be found in the driver\u2019s Persistence documentation .  /* This example instructs the library to unserialize root and embedded BSON\n * documents as PHP arrays, like the legacy driver (i.e. ext-mongo). */\n$client = new MongoDB\\Client(null, [], [\n    'typeMap' => ['root' => 'array', 'document' => 'array'],\n);  By default, the library will unserialize BSON documents and arrays as MongoDB\\Model\\BSONDocument  and  MongoDB\\Model\\BSONArray  objects,\nrespectively. Each of these model classes extends PHP\u2019s ArrayObject  class and implements the driver\u2019s MongoDB\\BSON\\Serializable  and MongoDB\\BSON\\Unserializable \ninterfaces.",
            "title": "MongoDB\\Client"
        },
        {
            "location": "/classes/client/#selecting-databases-and-collections",
            "text": "The Client class provides methods for creating Database or Collection instances\n(using its internal Manager instance). When selecting a Database or Collection,\nthe child will inherit options (e.g. read preference, type map) from the Client.\nNew options may also be provided to the  selectDatabase()  and selectCollection()  methods.  $client = new MongoDB\\Client;\n\n/* Select the \"demo\" database */\n$db = $client->selectDatabase('demo');\n\n/* Select the \"demo.users\" collection */\n$collection = $client->selectCollection('demo', 'users');\n\n/* selectDatabase() and selectCollection() also take an options array, which can\n * override any options inherited from the Client. */\n$db = $client->selectDatabase('demo', [\n    'readPreference' => new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_SECONDARY),\n]);\n\n/* The property accessor may also be used to select a database without\n * specifying additional options. PHP's complex syntax may be used for selecting\n * databases whose names contain special characters (e.g. \"-\"). */\n$db = $client->demo;\n$db = $client->{'another-app'};",
            "title": "Selecting Databases and Collections"
        },
        {
            "location": "/classes/client/#database-management",
            "text": "The Client class has several methods for managing databases.  Dropping Databases \u00b6  $client = new MongoDB\\Client;\n\n$result = $client->dropDatabase('demo');\nvar_dump($result);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#8 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(2) {\n    [\"dropped\"]=>\n    string(4) \"demo\"\n    [\"ok\"]=>\n    float(1)\n  }\n}  Enumerating Databases \u00b6  $client = new MongoDB\\Client;\n\n/* listDatabases() returns an iterator of MongoDB\\Model\\DatabaseInfo objects */\nforeach ($client->listDatabases() as $databaseInfo) {\n    var_dump($databaseInfo);\n}  The above example would output something similar to:  object(MongoDB\\Model\\DatabaseInfo)#4 (3) {\n  [\"name\"]=>\n  string(5) \"local\"\n  [\"sizeOnDisk\"]=>\n  float(65536)\n  [\"empty\"]=>\n  bool(false)\n}\nobject(MongoDB\\Model\\DatabaseInfo)#7 (3) {\n  [\"name\"]=>\n  string(4) \"test\"\n  [\"sizeOnDisk\"]=>\n  float(32768)\n  [\"empty\"]=>\n  bool(false)\n}",
            "title": "Database Management"
        },
        {
            "location": "/classes/database/",
            "text": "MongoDB\\Database\n\u00b6\n\n\nMongoDB\\Database\n provides methods for common operations on a database, such\nas creating, enumerating, and dropping collections.\n\n\nA Database may be constructed directly (using the extension\u2019s Manager class) or\nselected from the library\u2019s Client class. It supports the following options:\n\n\n\n\nreadConcern\n\n\nreadPreference\n\n\ntypeMap\n\n\nwriteConcern\n\n\n\n\nIf any options are omitted, they will be inherited from the Manager constructor\nargument or object from which the Database was selected.\n\n\nOperations within the Database class (e.g. \ncommand()\n) will generally inherit\nthe Database\u2019s options.\n\n\nSelecting Collections\n\u00b6\n\n\nThe Database class provides methods for creating Collection instances (using its\ninternal Manager instance). When selecting a Collection, the child will inherit\noptions (e.g. read preference, type map) from the Database. New options may also\nbe provided to the \nselectCollection()\n method.\n\n\n$db = (new MongoDB\\Client)->demo;\n\n/* Select the \"users\" collection */\n$collection = $db->selectCollection('users');\n\n/* selectCollection() also takes an options array, which can override any\n * options inherited from the Database. */\n$collection = $client->selectCollection('users', [\n    'readPreference' => new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_SECONDARY),\n]);\n\n/* The property accessor may also be used to select a collection without\n * specifying additional options. PHP's complex syntax may be used for selecting\n * collection whose names contain special characters (e.g. \".\"). */\n$collection = $db->users;\n$collection = $db->{'system.profile'};\n\n\n\n\nDatabase-level Operations\n\u00b6\n\n\nThe Database class has methods for database-level operations, such as dropping\nthe database, executing a command, or managing the database\u2019s collections.\n\n\nDropping the Database\n\u00b6\n\n\n$db = (new MongoDB\\Client)->demo;\n\n$result = $db->drop();\nvar_dump($result);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(2) {\n    [\"dropped\"]=>\n    string(4) \"demo\"\n    [\"ok\"]=>\n    float(1)\n  }\n}\n\n\n\n\nExecuting a Command\n\u00b6\n\n\nWhile the library provides helpers for some common database commands, it is far\nfrom an \nexhaustive list\n.\nThe following example demonstrates how the\n\ncreateUser\n\ncommand might be invoked:\n\n\n$db = (new MongoDB\\Client)->demo;\n\n/* Define a command document for creating a new database user */\n$createUserCmd = [\n    'createUser' => 'username',\n    'pwd' => 'password',\n    'roles' => [ 'readWrite' ],\n];\n\n/* It doesn't hurt to specify an explicit read preference for the command, in\n * case the Database was created with a different read preference. This isn't\n * required for other command helpers, as the library knows which commands might\n * require a primary; however, the Database::command() method is generic. */\n$cursor = $db->command($createUserCmd, [\n    'readPreference' => new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_PRIMARY),\n]);\n\n/* The command result will be the first and only document in the cursor */\nvar_dump($cursor->toArray()[0]);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#8 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(1) {\n    [\"ok\"]=>\n    float(1)\n  }\n}\n\n\n\n\nCollection Management\n\u00b6\n\n\nThe Database class has several methods for managing collections.\n\n\nCreating Collections\n\u00b6\n\n\nMongoDB already creates collections implicitly when they are first referenced in\ncommands (e.g. inserting a document into a new collection); however, collections\nmay also be explicitly created with specific options. This is useful for\ncreating\n\ncapped collections\n,\nenabling\n\ndocument validation\n,\nor supplying storage engine options.\n\n\n$db = (new MongoDB\\Client)->demo;\n\n$result = $db->createCollection('users', [\n    'validator' => [\n        'username' => ['$type' => 'string'],\n        'email' => ['$regex' => '@mongodb\\.com$'],\n    ],\n]);\nvar_dump($result);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(1) {\n    [\"ok\"]=>\n    float(1)\n  }\n}\n\n\n\n\nDropping Collections\n\u00b6\n\n\n$db = (new MongoDB\\Client)->demo;\n\n$result = $db->dropCollection('users');\nvar_dump($result);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(3) {\n    [\"ns\"]=>\n    string(10) \"demo.users\"\n    [\"nIndexesWas\"]=>\n    int(1)\n    [\"ok\"]=>\n    float(1)\n  }\n}\n\n\n\n\nEnumerating Collections\n\u00b6\n\n\nThe Database class implements MongoDB\u2019s\n\nEnumerating Collections specification\n.\n\n\n$db = (new MongoDB\\Client)->demo;\n\n/* listCollections() returns an iterator of MongoDB\\Model\\CollectionInfo objects */\nforeach ($db->listCollections() as $collectionInfo) {\n    var_dump($collectionInfo);\n}\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\CollectionInfo)#8 (2) {\n  [\"name\"]=>\n  string(5) \"users\"\n  [\"options\"]=>\n  array(0) {\n  }\n}\nobject(MongoDB\\Model\\CollectionInfo)#13 (2) {\n  [\"name\"]=>\n  string(14) \"system.profile\"\n  [\"options\"]=>\n  array(2) {\n    [\"capped\"]=>\n    bool(true)\n    [\"size\"]=>\n    int(1048576)\n  }\n}",
            "title": "Database"
        },
        {
            "location": "/classes/database/#mongodbdatabase",
            "text": "MongoDB\\Database  provides methods for common operations on a database, such\nas creating, enumerating, and dropping collections.  A Database may be constructed directly (using the extension\u2019s Manager class) or\nselected from the library\u2019s Client class. It supports the following options:   readConcern  readPreference  typeMap  writeConcern   If any options are omitted, they will be inherited from the Manager constructor\nargument or object from which the Database was selected.  Operations within the Database class (e.g.  command() ) will generally inherit\nthe Database\u2019s options.  Selecting Collections \u00b6  The Database class provides methods for creating Collection instances (using its\ninternal Manager instance). When selecting a Collection, the child will inherit\noptions (e.g. read preference, type map) from the Database. New options may also\nbe provided to the  selectCollection()  method.  $db = (new MongoDB\\Client)->demo;\n\n/* Select the \"users\" collection */\n$collection = $db->selectCollection('users');\n\n/* selectCollection() also takes an options array, which can override any\n * options inherited from the Database. */\n$collection = $client->selectCollection('users', [\n    'readPreference' => new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_SECONDARY),\n]);\n\n/* The property accessor may also be used to select a collection without\n * specifying additional options. PHP's complex syntax may be used for selecting\n * collection whose names contain special characters (e.g. \".\"). */\n$collection = $db->users;\n$collection = $db->{'system.profile'};",
            "title": "MongoDB\\Database"
        },
        {
            "location": "/classes/database/#database-level-operations",
            "text": "The Database class has methods for database-level operations, such as dropping\nthe database, executing a command, or managing the database\u2019s collections.  Dropping the Database \u00b6  $db = (new MongoDB\\Client)->demo;\n\n$result = $db->drop();\nvar_dump($result);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(2) {\n    [\"dropped\"]=>\n    string(4) \"demo\"\n    [\"ok\"]=>\n    float(1)\n  }\n}  Executing a Command \u00b6  While the library provides helpers for some common database commands, it is far\nfrom an  exhaustive list .\nThe following example demonstrates how the createUser \ncommand might be invoked:  $db = (new MongoDB\\Client)->demo;\n\n/* Define a command document for creating a new database user */\n$createUserCmd = [\n    'createUser' => 'username',\n    'pwd' => 'password',\n    'roles' => [ 'readWrite' ],\n];\n\n/* It doesn't hurt to specify an explicit read preference for the command, in\n * case the Database was created with a different read preference. This isn't\n * required for other command helpers, as the library knows which commands might\n * require a primary; however, the Database::command() method is generic. */\n$cursor = $db->command($createUserCmd, [\n    'readPreference' => new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_PRIMARY),\n]);\n\n/* The command result will be the first and only document in the cursor */\nvar_dump($cursor->toArray()[0]);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#8 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(1) {\n    [\"ok\"]=>\n    float(1)\n  }\n}",
            "title": "Database-level Operations"
        },
        {
            "location": "/classes/database/#collection-management",
            "text": "The Database class has several methods for managing collections.  Creating Collections \u00b6  MongoDB already creates collections implicitly when they are first referenced in\ncommands (e.g. inserting a document into a new collection); however, collections\nmay also be explicitly created with specific options. This is useful for\ncreating capped collections ,\nenabling document validation ,\nor supplying storage engine options.  $db = (new MongoDB\\Client)->demo;\n\n$result = $db->createCollection('users', [\n    'validator' => [\n        'username' => ['$type' => 'string'],\n        'email' => ['$regex' => '@mongodb\\.com$'],\n    ],\n]);\nvar_dump($result);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(1) {\n    [\"ok\"]=>\n    float(1)\n  }\n}  Dropping Collections \u00b6  $db = (new MongoDB\\Client)->demo;\n\n$result = $db->dropCollection('users');\nvar_dump($result);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(3) {\n    [\"ns\"]=>\n    string(10) \"demo.users\"\n    [\"nIndexesWas\"]=>\n    int(1)\n    [\"ok\"]=>\n    float(1)\n  }\n}  Enumerating Collections \u00b6  The Database class implements MongoDB\u2019s Enumerating Collections specification .  $db = (new MongoDB\\Client)->demo;\n\n/* listCollections() returns an iterator of MongoDB\\Model\\CollectionInfo objects */\nforeach ($db->listCollections() as $collectionInfo) {\n    var_dump($collectionInfo);\n}  The above example would output something similar to:  object(MongoDB\\Model\\CollectionInfo)#8 (2) {\n  [\"name\"]=>\n  string(5) \"users\"\n  [\"options\"]=>\n  array(0) {\n  }\n}\nobject(MongoDB\\Model\\CollectionInfo)#13 (2) {\n  [\"name\"]=>\n  string(14) \"system.profile\"\n  [\"options\"]=>\n  array(2) {\n    [\"capped\"]=>\n    bool(true)\n    [\"size\"]=>\n    int(1048576)\n  }\n}",
            "title": "Collection Management"
        },
        {
            "location": "/classes/collection/",
            "text": "MongoDB\\Collection\n\u00b6\n\n\nMongoDB\\Collection\n is perhaps the most useful class in this library. It\nprovides methods for common operations on a collection, such as inserting\ndocuments, querying, updating, counting, etc.\n\n\nA Collection may be constructed directly (using the extension\u2019s Manager class)\nor selected from the library\u2019s Client class. It supports the following options:\n\n\n\n\nreadConcern\n\n\nreadPreference\n\n\ntypeMap\n\n\nwriteConcern\n\n\n\n\nIf any options are omitted, they will be inherited from the Manager constructor\nargument or object from which the Collection was selected.\n\n\nOperations within the Collection class (e.g. \nfind()\n, \ninsertOne()\n) will\ngenerally inherit the Collection\u2019s options. One notable exception to this rule\nis that \naggregate()\n (when not using a cursor) and the \nfindAndModify\n variants\ndo not yet support a type map option due to a driver limitation. This means that\nthey will return BSON documents and arrays as \nstdClass\n objects and PHP arrays,\nrespectively.\n\n\nCollection-level Operations\n\u00b6\n\n\nThe Collection class has methods for collection-level operations, such as\ndropping the collection, CRUD operations, or managing the collection\u2019s indexes.\n\n\nDropping the Collection\n\u00b6\n\n\n$collection = (new MongoDB\\Client)->demo->zips;\n\n$result = $collection->drop();\nvar_dump($result);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(3) {\n    [\"ns\"]=>\n    string(9) \"demo.zips\"\n    [\"nIndexesWas\"]=>\n    int(1)\n    [\"ok\"]=>\n    float(1)\n  }\n}\n\n\n\n\nCRUD Operations\n\u00b6\n\n\nCRUD is an acronym for Create, Read, Update, and Delete. The Collection class\nimplements MongoDB\u2019s cross-driver\n\nCRUD specification\n,\nwhich defines a common API for collection-level read and write methods.\n\n\nEach method on the Collection class corresponds to a particular Operation class\nwithin the library. The Collection\u2019s method merely merges in relevant options\n(e.g. read preferences, type maps). Documentation for each CRUD method and its\noptions may be found in either the CRUD specification or those Operation\nclasses.\n\n\nAPI Differences from the Legacy Driver\n\u00b6\n\n\nThe CRUD API has some notable differences from the legacy driver\u2019s\n\nMongoCollection\n class:\n\n\n\n\ninsert()\n and \nbatchInsert()\n have been renamed to \ninsertOne()\n and\n   \ninsertMany()\n, respectively.\n\n\nupdate()\n has been split into \nupdateOne()\n, \nupdateMany()\n, and\n   \nreplaceOne()\n.\n\n\nremove()\n has been split into \ndeleteOne()\n and \ndeleteMany()\n.\n\n\nfindAndModify()\n has been split into \nfindOneAndDelete()\n,\n   \nfindOneAndReplace()\n, and \nfindOneAndUpdate()\n.\n\n\nsave()\n, which was syntactic sugar for an insert or upsert operation, has\n    been removed in favor of explicitly using \ninsertOne()\n or \nreplaceOne()\n\n    (with the \nupsert\n option).\n\n\naggregate()\n and \naggregateCursor()\n have been consolidated into a single\n   \naggregate()\n method.\n\n\nA general-purpose \nbulkWrite()\n method replaces the legacy driver\u2019s\n   \nMongoWriteBatch\n class.\n\n\n\n\nThe general rule in designing our new API was that explicit method names were\npreferable to overloaded terms found in the old API. For instance, \nsave()\n and\n\nfindAndModify()\n had two or three very different modes of operation, depending\non their arguments. These new methods names also distinguish between\n\nupdating specific fields\n\nand \nfull-document replacement\n.\n\n\nFinding One or More Document(s)\n\u00b6\n\n\nThe \nfindOne()\n and \nfind()\n methods may be used to query for one or multiple\ndocuments.\n\n\n$collection = (new MongoDB\\Client)->demo->zips;\n\n$document = $collection->findOne(['_id' => '94301']);\nvar_dump($document);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#13 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(5) {\n    [\"_id\"]=>\n    string(5) \"94301\"\n    [\"city\"]=>\n    string(9) \"PALO ALTO\"\n    [\"loc\"]=>\n    object(MongoDB\\Model\\BSONArray)#12 (1) {\n      [\"storage\":\"ArrayObject\":private]=>\n      array(2) {\n        [0]=>\n        float(-122.149685)\n        [1]=>\n        float(37.444324)\n      }\n    }\n    [\"pop\"]=>\n    int(15965)\n    [\"state\"]=>\n    string(2) \"CA\"\n  }\n}\n\n\n\n\nThe \nfind()\n method returns a\n\nMongoDB\\Driver\\Cursor\n object, which\nmay be iterated upon to access all matched documents.\n\n\nIndex Management\n\u00b6\n\n\nThe Collection class implements MongoDB\u2019s cross-driver\n\nIndex Management\n\nand\n\nEnumerating Indexes\n\nspecifications, which defines a common API for index-related methods.\n\n\nCreating Indexes\n\u00b6\n\n\n$collection = (new MongoDB\\Client)->demo->zips;\n\n$result = $collection->createIndex(['state' => 1]);\nvar_dump($result);\n\n\n\n\nThe above example would output something similar to:\n\n\nstring(7) \"state_1\"\n\n\n\n\nDropping Indexes\n\u00b6\n\n\n$collection = (new MongoDB\\Client)->demo->zips;\n\n$result = $collection->dropIndex('state_1');\nvar_dump($result);\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(2) {\n    [\"nIndexesWas\"]=>\n    int(2)\n    [\"ok\"]=>\n    float(1)\n  }\n}\n\n\n\n\nEnumerating Indexes\n\u00b6\n\n\n/* listIndexes() returns an iterator of MongoDB\\Model\\IndexInfo objects */\n$collection = (new MongoDB\\Client)->demo->zips;\n\nforeach ($collection->listIndexes() as $indexInfo) {\n    var_dump($indexInfo);\n}\n\n\n\n\nThe above example would output something similar to:\n\n\nobject(MongoDB\\Model\\IndexInfo)#4 (4) {\n  [\"v\"]=>\n  int(1)\n  [\"key\"]=>\n  array(1) {\n    [\"_id\"]=>\n    int(1)\n  }\n  [\"name\"]=>\n  string(4) \"_id_\"\n  [\"ns\"]=>\n  string(9) \"demo.zips\"\n}",
            "title": "Collection"
        },
        {
            "location": "/classes/collection/#mongodbcollection",
            "text": "MongoDB\\Collection  is perhaps the most useful class in this library. It\nprovides methods for common operations on a collection, such as inserting\ndocuments, querying, updating, counting, etc.  A Collection may be constructed directly (using the extension\u2019s Manager class)\nor selected from the library\u2019s Client class. It supports the following options:   readConcern  readPreference  typeMap  writeConcern   If any options are omitted, they will be inherited from the Manager constructor\nargument or object from which the Collection was selected.  Operations within the Collection class (e.g.  find() ,  insertOne() ) will\ngenerally inherit the Collection\u2019s options. One notable exception to this rule\nis that  aggregate()  (when not using a cursor) and the  findAndModify  variants\ndo not yet support a type map option due to a driver limitation. This means that\nthey will return BSON documents and arrays as  stdClass  objects and PHP arrays,\nrespectively.",
            "title": "MongoDB\\Collection"
        },
        {
            "location": "/classes/collection/#collection-level-operations",
            "text": "The Collection class has methods for collection-level operations, such as\ndropping the collection, CRUD operations, or managing the collection\u2019s indexes.  Dropping the Collection \u00b6  $collection = (new MongoDB\\Client)->demo->zips;\n\n$result = $collection->drop();\nvar_dump($result);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(3) {\n    [\"ns\"]=>\n    string(9) \"demo.zips\"\n    [\"nIndexesWas\"]=>\n    int(1)\n    [\"ok\"]=>\n    float(1)\n  }\n}",
            "title": "Collection-level Operations"
        },
        {
            "location": "/classes/collection/#crud-operations",
            "text": "CRUD is an acronym for Create, Read, Update, and Delete. The Collection class\nimplements MongoDB\u2019s cross-driver CRUD specification ,\nwhich defines a common API for collection-level read and write methods.  Each method on the Collection class corresponds to a particular Operation class\nwithin the library. The Collection\u2019s method merely merges in relevant options\n(e.g. read preferences, type maps). Documentation for each CRUD method and its\noptions may be found in either the CRUD specification or those Operation\nclasses.  API Differences from the Legacy Driver \u00b6  The CRUD API has some notable differences from the legacy driver\u2019s MongoCollection  class:   insert()  and  batchInsert()  have been renamed to  insertOne()  and\n    insertMany() , respectively.  update()  has been split into  updateOne() ,  updateMany() , and\n    replaceOne() .  remove()  has been split into  deleteOne()  and  deleteMany() .  findAndModify()  has been split into  findOneAndDelete() ,\n    findOneAndReplace() , and  findOneAndUpdate() .  save() , which was syntactic sugar for an insert or upsert operation, has\n    been removed in favor of explicitly using  insertOne()  or  replaceOne() \n    (with the  upsert  option).  aggregate()  and  aggregateCursor()  have been consolidated into a single\n    aggregate()  method.  A general-purpose  bulkWrite()  method replaces the legacy driver\u2019s\n    MongoWriteBatch  class.   The general rule in designing our new API was that explicit method names were\npreferable to overloaded terms found in the old API. For instance,  save()  and findAndModify()  had two or three very different modes of operation, depending\non their arguments. These new methods names also distinguish between updating specific fields \nand  full-document replacement .  Finding One or More Document(s) \u00b6  The  findOne()  and  find()  methods may be used to query for one or multiple\ndocuments.  $collection = (new MongoDB\\Client)->demo->zips;\n\n$document = $collection->findOne(['_id' => '94301']);\nvar_dump($document);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#13 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(5) {\n    [\"_id\"]=>\n    string(5) \"94301\"\n    [\"city\"]=>\n    string(9) \"PALO ALTO\"\n    [\"loc\"]=>\n    object(MongoDB\\Model\\BSONArray)#12 (1) {\n      [\"storage\":\"ArrayObject\":private]=>\n      array(2) {\n        [0]=>\n        float(-122.149685)\n        [1]=>\n        float(37.444324)\n      }\n    }\n    [\"pop\"]=>\n    int(15965)\n    [\"state\"]=>\n    string(2) \"CA\"\n  }\n}  The  find()  method returns a MongoDB\\Driver\\Cursor  object, which\nmay be iterated upon to access all matched documents.",
            "title": "CRUD Operations"
        },
        {
            "location": "/classes/collection/#index-management",
            "text": "The Collection class implements MongoDB\u2019s cross-driver Index Management \nand Enumerating Indexes \nspecifications, which defines a common API for index-related methods.  Creating Indexes \u00b6  $collection = (new MongoDB\\Client)->demo->zips;\n\n$result = $collection->createIndex(['state' => 1]);\nvar_dump($result);  The above example would output something similar to:  string(7) \"state_1\"  Dropping Indexes \u00b6  $collection = (new MongoDB\\Client)->demo->zips;\n\n$result = $collection->dropIndex('state_1');\nvar_dump($result);  The above example would output something similar to:  object(MongoDB\\Model\\BSONDocument)#11 (1) {\n  [\"storage\":\"ArrayObject\":private]=>\n  array(2) {\n    [\"nIndexesWas\"]=>\n    int(2)\n    [\"ok\"]=>\n    float(1)\n  }\n}  Enumerating Indexes \u00b6  /* listIndexes() returns an iterator of MongoDB\\Model\\IndexInfo objects */\n$collection = (new MongoDB\\Client)->demo->zips;\n\nforeach ($collection->listIndexes() as $indexInfo) {\n    var_dump($indexInfo);\n}  The above example would output something similar to:  object(MongoDB\\Model\\IndexInfo)#4 (4) {\n  [\"v\"]=>\n  int(1)\n  [\"key\"]=>\n  array(1) {\n    [\"_id\"]=>\n    int(1)\n  }\n  [\"name\"]=>\n  string(4) \"_id_\"\n  [\"ns\"]=>\n  string(9) \"demo.zips\"\n}",
            "title": "Index Management"
        }
    ]
}